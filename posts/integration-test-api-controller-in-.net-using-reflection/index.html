<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Integration Test Api in .Net Using Reflection | Devies blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.
The key reasons are:
Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested Self contained i.e. the test has no external dependencies on a deployed environment etc. Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function The problem In my case the goal was to setup a test suite for a ."><meta name=generator content="Hugo 0.107.0"><meta name=robots content="index, follow"><link rel=stylesheet href=/blog/ananke/css/main.min.49b20d3cec9ed5416b049a3758cf8a4707639bd0d32cee144918c11a5bbaddd2.css><link rel="shortcut icon" href=/blog/favicon.ico type=image/x-icon><meta property="og:title" content="Integration Test Api in .Net Using Reflection"><meta property="og:description" content="There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.
The key reasons are:
Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested Self contained i.e. the test has no external dependencies on a deployed environment etc. Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function The problem In my case the goal was to setup a test suite for a ."><meta property="og:type" content="article"><meta property="og:url" content="https://deviesdevelopment.github.io/blog/posts/integration-test-api-controller-in-.net-using-reflection/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-02T09:07:50+02:00"><meta property="article:modified_time" content="2022-08-02T09:07:50+02:00"><meta itemprop=name content="Integration Test Api in .Net Using Reflection"><meta itemprop=description content="There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.
The key reasons are:
Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested Self contained i.e. the test has no external dependencies on a deployed environment etc. Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function The problem In my case the goal was to setup a test suite for a ."><meta itemprop=datePublished content="2022-08-02T09:07:50+02:00"><meta itemprop=dateModified content="2022-08-02T09:07:50+02:00"><meta itemprop=wordCount content="355"><meta itemprop=keywords content=".NET,Test,Api,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Integration Test Api in .Net Using Reflection"><meta name=twitter:description content="There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.
The key reasons are:
Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested Self contained i.e. the test has no external dependencies on a deployed environment etc. Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function The problem In my case the goal was to setup a test suite for a ."><script async src="https://www.googletagmanager.com/gtag/js?id=G-72VEGX2X3B"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-72VEGX2X3B",{anonymize_ip:!1})}</script></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/blog/logo.png class="w100 mw5-ns" alt="Devies blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Integration Test Api in .Net Using Reflection</h1><p class=tracked>By <strong>Albin Bramst√•ng</strong></p><time class="f6 mv4 dib tracked" datetime=2022-08-02T09:07:50+02:00>August 2, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.</p><p>The key reasons are:</p><ul><li>Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested</li><li>Self contained i.e. the test has no external dependencies on a deployed environment etc.</li><li>Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function</li></ul><h2 id=the-problem>The problem</h2><p>In my case the goal was to setup a test suite for a .NET web api. I quickly realized that the naive way to explicitly instantiate every controller plus all dependencies would lead
to lots of repeated boilerplate code in order to setup a test case. I also wanted to make use of the existing <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0">DI</a> configuration.<br>So how to create a generic setup where new test cases is a breeze to create? ü§î</p><h2 id=the-solution>The solution</h2><p>Reflection!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ControllerBuilder</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T GetController&lt;T&gt;()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> serviceProvider = <span style=color:#66d9ef>new</span> ServiceCollection()
</span></span><span style=display:flex><span>            .AddServices()
</span></span><span style=display:flex><span>            .SetupMock&lt;T&gt;()
</span></span><span style=display:flex><span>            .BuildServiceProvider();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> args = <span style=color:#66d9ef>typeof</span>(T)
</span></span><span style=display:flex><span>            .GetConstructors(BindingFlags.Instance | BindingFlags.Public)
</span></span><span style=display:flex><span>            .First()
</span></span><span style=display:flex><span>            .GetParameters()
</span></span><span style=display:flex><span>            .Select(p =&gt; serviceProvider.GetService(p.ParameterType))
</span></span><span style=display:flex><span>            .ToArray();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (T)Activator.CreateInstance(<span style=color:#66d9ef>typeof</span>(T), args)!;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> IServiceCollection SetupMock&lt;T&gt;(<span style=color:#66d9ef>this</span> IServiceCollection services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.Replace(<span style=color:#66d9ef>new</span> ServiceDescriptor(<span style=color:#66d9ef>typeof</span>(ILogger&lt;T&gt;), <span style=color:#66d9ef>new</span> Mock&lt;ILogger&lt;T&gt;&gt;().Object));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServiceConfiguration</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddServices(<span style=color:#66d9ef>this</span> IServiceCollection services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Instead of creating everything manually I built this. It takes the controller type, extracts all parameters from the public constructor, matches them with a real or mocked instance in
the service collection and creates the controller instance for you. Simple as that! The two extension methods <strong>SetupMock</strong> and <strong>AddServices</strong> are convenient ways to
setup the real service configuration and the mocked one. The approach is to only mock what you need to mock and try to use as much real code as possible.</p><p>A small test case will look like this. Very nice! üëç</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Fact]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Get_Returns_Data()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> controller = ControllerBuilder.GetController&lt;WeatherForecastController&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> response = controller.Get().Result <span style=color:#66d9ef>as</span> OkObjectResult;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = response?.Value <span style=color:#66d9ef>as</span> IEnumerable&lt;WeatherForecast&gt;;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Assert.NotNull(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>    Assert.NotEmpty(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul class=pa0><li class="list di"><a href=/blog/tags/.net/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">.NET</a></li><li class="list di"><a href=/blog/tags/test/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Test</a></li><li class="list di"><a href=/blog/tags/api/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Api</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/posts/mitigating-primitive-obsession-in-asp.net-web-api/>Mitigating Primitive Obsession in ASP.NET Web Api</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://deviesdevelopment.github.io/blog/>&copy; Devies blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>