<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Minimize Java Lambda Cold Start Times | Devies blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.
The problem with cold starts arises when there are no &ldquo;warm&rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic."><meta name=generator content="Hugo 0.99.1"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/blog/ananke/css/main.min.ceb444b34b6d1508dbe3ab8cbf937a305a3f952886a8f52fbbb14068f75e1a94.css><link rel="shortcut icon" href=/blog/favicon.ico type=image/x-icon><meta property="og:title" content="Minimize Java Lambda Cold Start Times"><meta property="og:description" content="If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.
The problem with cold starts arises when there are no &ldquo;warm&rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic."><meta property="og:type" content="article"><meta property="og:url" content="https://deviesdevelopment.github.io/blog/posts/implementation/aws/2021/04/08/minimize-java-lambda-coldstarts.html/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-08T09:25:58+00:00"><meta property="article:modified_time" content="2021-04-08T09:25:58+00:00"><meta itemprop=name content="Minimize Java Lambda Cold Start Times"><meta itemprop=description content="If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.
The problem with cold starts arises when there are no &ldquo;warm&rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic."><meta itemprop=datePublished content="2021-04-08T09:25:58+00:00"><meta itemprop=dateModified content="2021-04-08T09:25:58+00:00"><meta itemprop=wordCount content="704"><meta itemprop=keywords content="AWS,Java,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Minimize Java Lambda Cold Start Times"><meta name=twitter:description content="If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.
The problem with cold starts arises when there are no &ldquo;warm&rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/blog/logo.png class="w100 mw5-ns" alt="Devies blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Minimize Java Lambda Cold Start Times</h1><p class=tracked>By <strong>Gustav Sundin, Rickard Andersson</strong></p><time class="f6 mv4 dib tracked" datetime=2021-04-08T09:25:58Z>April 8, 2021</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.</p><p>The problem with cold starts arises when there are no &ldquo;warm&rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic. The most commonly occurring scenario when this happens is probably when an endpoint goes from no traffic at all in a while (and thus having no warm lambdas ready) to suddenly having one or more incoming requests to serve.</p><p>In practice, this means that the issue with cold starts will become much less problematic the more traffic your service gets, especially if the traffic is somewhat evenly distributed across time. For an endpoint with frequent traffic, a few cold starts here and there will probably not impact your P99 latency in a significant way. That being said, if your use case does not allow for a few requests in a while getting response times of at least a couple of seconds or more, then you should probably not use Java at all.</p><h2 id=minimizing-cold-start-times>Minimizing cold start times</h2><p>Assuming you are fine with some cold starts with noticeable delays, what can be done in order to minimize the time these cold starts consume as much as possible? Here is a list of things to do to minimize the cold starts for your serverless application.</p><h3 id=increase-runtime-memory>Increase runtime memory</h3><p>The more memory you assign to your lambda function, the faster it will spin up because it also gets access to more CPU power. Note that increasing the memory size will often in fact result in a <em>lower</em> runtime cost (since the cost is calculated as function execution time times available memory). There&rsquo;s a sweet spot at 1,5GB according to <a href=https://github.com/alexcasalboni/aws-lambda-power-tuning>this article</a> from 2020.</p><h3 id=reduce-application-size>Reduce application size</h3><p>The more classes you squeeze into your application, the longer it will take to initialize. I wouldn&rsquo;t say that you should go so far as to avoid introducing new classes to your codebase wherever it makes the code more readable and maintainable, but there are two other approaches you should follow which gives a much larger payoff:</p><ul><li>Get rid of unnecessary dependencies. Lean towards using Java native functions instead of bringing in Apache commons (for example, use the native Java 11 HTTP client instead of Apache). Try to replace AWS v1 clients with their v2 counterparts. Less is faster.</li><li>Get rid of unreferenced classed using <a href=https://github.com/Guardsquare/proguard>Proguard</a>.</li></ul><h3 id=leverage-boosted-cpu-access>Leverage boosted CPU access</h3><p>During the initialization phase, AWS actually gives you access to much more CPU power than the capped limit you will have during your normal lambda execution. You can leverage this by initializing heavy-to-load clients (such as any AWS clients) in the constructor or as static variables, so that they will be initialized when the lambda has access to the boosted CPU power. This holds whenever you have to initialize clients that will be needed during most lambda executions. On the other hand, if you have clients that will normally not be used except for a few corner cases, it could make more sense to only initialize them when they are actually needed. You will have to use your common sense here.</p><h3 id=run-lambdas-outside-of-vpc>Run lambdas outside of VPC</h3><p>Launching a lambda function inside a VPC adds a lot of time to your cold starts. Therefore you should investigate if you can have an architecture where you do not need to have your lambdas running inside a VPC.</p><h2 id=conclusion>Conclusion</h2><p>As described in this blog post, there are a few methods that can be used in order to minimize the cold start times for your Java lambdas. For more details, have a look at <a href=https://youtu.be/ddg1u5HLwg8>this great talk</a> from re:Invent. However, you will not be able to get rid of the cold start times completely this way. If you are running a performance critical service, you should instead consider switching to another programming language than Java (i.e. Node.js, Go or Python) or another hosting method than AWS Lambda (i.e. containerized application).</p><p>By Gustav Sundin & Rickard Andersson</p><ul class=pa0><li class=list><a href=/blog/tags/aws class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">AWS</a></li><li class=list><a href=/blog/tags/java class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Java</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/posts/2021-03-30-dynamodb-migrations/>Migrating data between DynamoDB tables</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://deviesdevelopment.github.io/blog>&copy; Devies blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>