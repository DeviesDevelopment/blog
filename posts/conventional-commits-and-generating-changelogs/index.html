<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Conventional Commits and Generating Changelogs | Devies blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing. Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again! With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible."><meta name=generator content="Hugo 0.102.3"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/blog/ananke/css/main.min.9036e8ca4a3287e27ab2eb511a473b75bdc83acf6db11ab67b1704e7b4fdd475.css><link rel="shortcut icon" href=/blog/favicon.ico type=image/x-icon><meta property="og:title" content="Conventional Commits and Generating Changelogs"><meta property="og:description" content="Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing. Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again! With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible."><meta property="og:type" content="article"><meta property="og:url" content="https://deviesdevelopment.github.io/blog/posts/conventional-commits-and-generating-changelogs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-27T16:43:10+02:00"><meta property="article:modified_time" content="2022-07-27T16:43:10+02:00"><meta itemprop=name content="Conventional Commits and Generating Changelogs"><meta itemprop=description content="Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing. Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again! With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible."><meta itemprop=datePublished content="2022-07-27T16:43:10+02:00"><meta itemprop=dateModified content="2022-07-27T16:43:10+02:00"><meta itemprop=wordCount content="1488"><meta itemprop=keywords content="Conventional Commits,changelogs,automation,CI,Azure Devops,documentation,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Conventional Commits and Generating Changelogs"><meta name=twitter:description content="Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing. Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again! With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/blog/logo.png class="w100 mw5-ns" alt="Devies blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Conventional Commits and Generating Changelogs</h1><p class=tracked>By <strong>Johan Hage</strong></p><time class="f6 mv4 dib tracked" datetime=2022-07-27T16:43:10+02:00>July 27, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing.
Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again!
With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible.
In this post I will go through how we utilized <code>Conventional Commits</code>, an Azure Devops extension called <code>Commitizen</code> and an npm package called <code>Standard version</code> to automatically generate changelogs in our Azure Devops CI environment.</p><p>Before getting in to the details of how our solution ended up working there are some concepts that are important.</p><h2 id=conventional-commits>Conventional Commits</h2><p>Conventional Commits is a specification used to format commit messages consistently.
The full specification can be found <a href=https://www.conventionalcommits.org/en/v1.0.0/#specification>here</a>, but to summarize, it is a convention where each commit message is divided into the following structure:</p><pre><code>type(optional scope): subject
</code></pre><ul><li><code>type</code> describes the purpose of the commit, such as a <code>fix</code> (for bug fix), <code>feat</code> (for feature), <code>refactor</code> (for refactorization) etc.</li><li><code>scope</code> is optional and might refer to the specific feature you&rsquo;re working on or what ever seems relevant</li><li><code>subject</code> is a relevant description of what has been done in the commit and should of course be written well enough to be present in a changelog!</li></ul><p>Depending on what type is being used for the commit message it can be mapped to a MAJOR, MINOR or PATCH version number as explained below.</p><h3 id=semantic-versioning>Semantic versioning</h3><p>Semantic versioning is a commonly used standard for version numbers.</p><p>From the official page of <a href=https://semver.org/>Semantic Versioning</a> (or semver)</p><blockquote><p>Given a version number MAJOR.MINOR.PATCH, increment the:</p><ul><li>MAJOR version when you make incompatible API changes</li><li>MINOR version when you add functionality in a backwards compatible manner</li><li>PATCH version when you make backwards compatible bug fixes</li></ul><p>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.</p></blockquote><h2 id=changelogs>Changelogs</h2><p>Now, while Conventional Commits might just sound like you have to spend time on writing better commit messages that no one is going to read anyway, sticking to the convention will bring along some nifty benefits.
Of course it will give you and your team a much clearer overview of what has been done on each commit, but also the structure of each commit can be utilized to generate changelogs automatically!
Not only that, since there is a clear indication of what type of commits has been made the version number can be automatically increased, allowing you to not have to think about that at all!</p><p>The way that works is by connecting different types of commits to different version numbers:</p><ul><li>If a <code>BREAKING CHANGE</code> has been pushed since the last release, the MAJOR version will be increased (1.5.2 => 2.5.2)</li><li>If a <code>feat</code> has been pushed since the last release, the MINOR version will be increased (1.5.2 => 1.6.2)</li><li>If none of the above, the PATCH version will be increased (1.5.2 => 1.5.3)</li></ul><p>In action, one common way of doing this is by creating a CI workflow, such as via Github Actions or, in our case, Azure Devops Pipelines.
The workflow would be run every time a release was being made.
Then a tool is used to automatically generate changelogs and increase the version number.
The changelog generator would take all the commits made since the last time that the changelog was generated by keeping track of the git tag with the latest version number, generate a changelog and push it to the specified branch.
More on the specifics later.</p><p>However, one issue with having the commit messages being directly used when generating the changelogs is that it does not always tie in well with your way of working with git.
In our case for example, we squash merged our branches every time we made a pull request, meaning that all the commit messages would be merged into one.
A workaround for this would be to enforce that each PR would only consist of one commit which adheres to the Conventional Commits standard.
However this would of course affect how people use git where you would either have to make sure to only have one commit that you amend changes to (and force push if the commit was already pushed before), or that you manually squash all the commits before finalizing the PR.</p><p>We wanted a way that was less intrusive to the way of working.</p><h3 id=commitizen>Commitizen</h3><p>While there are quite a few tools that can assist in sticking to the conventional commits format, such as <a href=https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13>this tool</a> which can be used as a git pre-commit hook to enforce commit messages comply with the format, our case was a bit different and required some things to be done differently.</p><p>What we wanted was a way to utilize the title of our pull requests as the squashed commit message, after having made sure that the title follows the convention.
This would allow us to work with our branches and commits as usual, and then make sure that the PR is explaining the work clearly enough.
Unfortunately this wasn&rsquo;t a trivial task as all we could find in regards to using the PR title for squash merge commits was that it could be done, but not without Azure Devops adding the PR number before the message, meaning it would be rendered unusable in regards to the changelog generation.</p><p>Meanwhile, Github had <a href=https://github.blog/changelog/2022-05-11-default-to-pr-titles-for-squash-merge-commit-messages/>released the exact feature we were looking for</a> just the week before, along with having a ton of different <a href="https://github.com/marketplace?type=actions&query=conventional+commits+PR+title+">Github Actions</a> that could be used for ensuring that PR titles adhere to the convention.</p><p>But after extensive searching we found an Azure Devops extension called <a href="https://marketplace.visualstudio.com/items?itemName=aguafrommars.cz-pull-request">Commitizen Pull Request</a>.
An extension that adds an option to each PR in Azure Devops which when used will provide a form.
In the form you&rsquo;d fill in things related to Conventional Commits, such as type, scope, breaking changes and of course subject.
This will then be used to provide a message to the squashed commit when the PR is merged.</p><p>The only issue remaining with this is that we&rsquo;ve not found a way to enforce that this option is being used when completing PRs in Azure Devops, meaning that people could still accidentally use the regular complete button and have there changes not be part of the changelogs.</p><h2 id=pipeline-and-standard-version>Pipeline and Standard version</h2><p>With the commit messages in place we could finally move on to actually generating changelogs.
This part could of course differ a lot depending on your CI environment.
In our case we have a build pipeline that is being run every time a push is being made to the main branch which in turn &ldquo;releases&rdquo; a new image that is pushed to our different live environments.
We extended this pipeline with the following stage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span>- <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>standard_version</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>displayName</span>: <span style=color:#ae81ff>Generate changelogs and bump version</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>jobs</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>job</span>: <span style=color:#ae81ff>standard_version</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>pool</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>vmImage</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>checkout</span>: <span style=color:#ae81ff>self</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>persistCredentials</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>script</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            git config --global user.email &#39;azure@bot.com&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            git config --global user.name &#39;Azure Bot&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            npx standard-version
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            git push --follow-tags origin HEAD:$(Build.SourceBranchName)</span>            
</span></span><span style=display:flex><span>          <span style=color:#f92672>condition</span>: <span style=color:#ae81ff>eq(variables[&#39;Build.SourceBranch&#39;], &#39;refs/heads/master&#39;)</span>
</span></span></code></pre></div><p>This stage uses an npm package called <a href=https://www.npmjs.com/package/standard-version>Standard Version</a> in order to generate the changelogs and increase the version number.
We also added the following settings in a file called <code>.versionrc</code> in order to make Standard Version be compatible with Azure Devops.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;releaseCommitMessageFormat&#34;</span>: <span style=color:#e6db74>&#34;chore(release): {{currentTag}} [skip ci]&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;compareUrlFormat&#34;</span>: <span style=color:#e6db74>&#34;{{host}}/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GT{{previousTag}}&amp;targetVersion=GT{{currentTag}}&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;commitUrlFormat&#34;</span>: <span style=color:#e6db74>&#34;{{host}}/*Organization*/*Project*/_git/*Project*/commit/{{hash}}&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;packageFiles&#34;</span>: [],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;bumpFiles&#34;</span>: []
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that <code>[skip ci]</code> is being added to the commit that is pushed in order to not create a loop of triggering the build pipeline every time the changelog commit is being pushed.</p><p>The <code>bumpFiles</code> array can be used to specify files which contains the version number of the project that should be automatically increased.
This is then used when generating changelogs to identify what commits should be included.
If left empty, the latest git tag is used instead.
(For node projects the package.json <code>version</code> property is bumped automatically, without being specified in <code>bumpFiles</code>)</p><p>In order for this to work we had to make sure our Azure Devops Build Service had access to pushing directly to our main branch, as this was of course not allowed for other users.</p><p>While it has become more and more good practise to release often, this has the unfortunate side effect of making our changelogs usually only contain one commit per version.</p><p><a href=https://jazz-twk.medium.com/automate-versioning-in-cicd-with-azure-devops-a65a9a6f4e69>This blog post by Jazz Tong</a> was of great help for making this work in Azure Devops.</p><p>The following is a sample from our <code>CHANGELOG.MD</code>:</p><h1 id=changelog>Changelog</h1><p>All notable changes to this project will be documented in this file. See <a href=https://github.com/conventional-changelog/standard-version>standard-version</a> for commit guidelines.</p><h3 id=2125httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2124targetversiongtv2125-2022-07-26><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.12.4&targetVersion=GTv2.12.5">2.12.5</a> (2022-07-26)</h3><h3 id=2124httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2123targetversiongtv2124-2022-07-26><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.12.3&targetVersion=GTv2.12.4">2.12.4</a> (2022-07-26)</h3><h3 id=2123httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2122targetversiongtv2123-2022-07-25><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.12.2&targetVersion=GTv2.12.3">2.12.3</a> (2022-07-25)</h3><h3 id=2122httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2121targetversiongtv2122-2022-07-25><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.12.1&targetVersion=GTv2.12.2">2.12.2</a> (2022-07-25)</h3><h3 id=2121httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2120targetversiongtv2121-2022-07-25><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.12.0&targetVersion=GTv2.12.1">2.12.1</a> (2022-07-25)</h3><h2 id=2120httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2110targetversiongtv2120-2022-07-22><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.11.0&targetVersion=GTv2.12.0">2.12.0</a> (2022-07-22)</h2><h3 id=features>Features</h3><ul><li>Updated review service and controller with ToothReview (<a href=https://dev.azure.com/*Organization*/*Project*/_git/*Project*/commit/a9986ec0a1ebce488da70605fcd0892241e00150>a9986ec</a>), closes <a href=https://dev.azure.com/*Organization*/*Project*/_git/*Project*/issues/899>#899</a></li></ul><h2 id=2110httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv2100targetversiongtv2110-2022-07-22><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.10.0&targetVersion=GTv2.11.0">2.11.0</a> (2022-07-22)</h2><h3 id=features-1>Features</h3><ul><li>Added default value current timestamp for all ITimeStampedModel (<a href=https://dev.azure.com/*Organization*/*Project*/_git/*Project*/commit/73d1f51a2af37f227e75a80e843bff1366fa96ae>73d1f51</a>)</li></ul><h2 id=2100httpsdevazurecomorganizationproject_gitprojectbranchcomparebaseversiongtv290targetversiongtv2100-2022-07-21><a href="https://dev.azure.com/*Organization*/*Project*/_git/*Project*/branchCompare?baseVersion=GTv2.9.0&targetVersion=GTv2.10.0">2.10.0</a> (2022-07-21)</h2><ul class=pa0><li class=list><a href=/tags/conventional-commits class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Conventional Commits</a></li><li class=list><a href=/tags/changelogs class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">changelogs</a></li><li class=list><a href=/tags/automation class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">automation</a></li><li class=list><a href=/tags/ci class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">CI</a></li><li class=list><a href=/tags/azure-devops class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Azure Devops</a></li><li class=list><a href=/tags/documentation class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">documentation</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/posts/why-you-should-add-a-cypress-test-to-your-ci-cd-pipeline/>Why you should add a cypress test to your CI/CD pipeline</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://deviesdevelopment.github.io/blog>&copy; Devies blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>