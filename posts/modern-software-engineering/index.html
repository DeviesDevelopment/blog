<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Takeaways from Modern Software Engineering | Devies Tech Culture Business Blog</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="In the Devies book club we recently finished Modern Software Engineering by David Farley.
In Modern Software Engineering, Farley want to reclaim the meaning of engineering in “software engineering”.
It’s not just about coding, it’s about doing what works to build better software faster - This involves processes, tools and culture.
The software industry is not like the manufacturing.
The process of building software can’t be reduced to a production line; it’s rather a process of exploration and discovery.
In this context, Farley suggests that there are two critical core competencies that software engineers must master: learning and managing complexity."><meta name=generator content="Hugo 0.145.0"><meta name=robots content="index, follow"><meta name=author content="Jakob Larsson, Johan Iversen, Rickard Andersson, Sandra Ekholm, Simon Nielsen"><link rel=stylesheet href=/ananke/css/main.min.4e9ca4c01a14a843da606ff00ca20ce632e6f312233f7b1ed7bb33d8a1cdb60f.css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=canonical href=https://blog.devies.se/posts/modern-software-engineering/><meta property="og:url" content="https://blog.devies.se/posts/modern-software-engineering/"><meta property="og:site_name" content="Devies Tech Culture Business Blog"><meta property="og:title" content="Takeaways from Modern Software Engineering"><meta property="og:description" content="In the Devies book club we recently finished Modern Software Engineering by David Farley.
In Modern Software Engineering, Farley want to reclaim the meaning of engineering in “software engineering”. It’s not just about coding, it’s about doing what works to build better software faster - This involves processes, tools and culture.
The software industry is not like the manufacturing. The process of building software can’t be reduced to a production line; it’s rather a process of exploration and discovery. In this context, Farley suggests that there are two critical core competencies that software engineers must master: learning and managing complexity."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-01T12:55:42+02:00"><meta property="article:modified_time" content="2023-11-01T12:55:42+02:00"><meta itemprop=name content="Takeaways from Modern Software Engineering"><meta itemprop=description content="In the Devies book club we recently finished Modern Software Engineering by David Farley.
In Modern Software Engineering, Farley want to reclaim the meaning of engineering in “software engineering”. It’s not just about coding, it’s about doing what works to build better software faster - This involves processes, tools and culture.
The software industry is not like the manufacturing. The process of building software can’t be reduced to a production line; it’s rather a process of exploration and discovery. In this context, Farley suggests that there are two critical core competencies that software engineers must master: learning and managing complexity."><meta itemprop=datePublished content="2023-11-01T12:55:42+02:00"><meta itemprop=dateModified content="2023-11-01T12:55:42+02:00"><meta itemprop=wordCount content="881"><meta name=twitter:card content="summary"><meta name=twitter:title content="Takeaways from Modern Software Engineering"><meta name=twitter:description content="In the Devies book club we recently finished Modern Software Engineering by David Farley.
In Modern Software Engineering, Farley want to reclaim the meaning of engineering in “software engineering”. It’s not just about coding, it’s about doing what works to build better software faster - This involves processes, tools and culture.
The software industry is not like the manufacturing. The process of building software can’t be reduced to a production line; it’s rather a process of exploration and discovery. In this context, Farley suggests that there are two critical core competencies that software engineers must master: learning and managing complexity."><script async src="https://www.googletagmanager.com/gtag/js?id=G-72VEGX2X3B"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-72VEGX2X3B")}</script></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/logo.png class="w100 mw5-ns" alt="Devies Tech Culture Business Blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Takeaways from Modern Software Engineering</h1><p class=tracked><strong>Jakob Larsson, Johan Iversen, Rickard Andersson, Sandra Ekholm, Simon Nielsen</strong></p><time class="f6 mv4 dib tracked" datetime=2023-11-01T12:55:42+02:00>November 1, 2023</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>In the Devies book club we recently finished Modern Software Engineering by David Farley.</p><p>In Modern Software Engineering, Farley want to reclaim the meaning of engineering in “software engineering”.
It’s not just about coding, it’s about doing what works to build better software faster - This involves processes, tools and culture.</p><p>The software industry is not like the manufacturing.
The process of building software can’t be reduced to a production line; it’s rather a process of exploration and discovery.
In this context, Farley suggests that there are two critical core competencies that software engineers must master: <em>learning</em> and <em>managing complexity</em>.</p><p>Science has proven to be a good approach to learning.
Throughout the book Farley relates to techniques and strategies from the <a href=https://en.wikipedia.org/wiki/Scientific_method>scientific method</a> and show how we can apply ideas from science to solve practical problems in our everyday work.</p><p>In this post, we&rsquo;ll share some takeaways from the book.</p><h3 id=feedback-loops>Feedback loops</h3><p>Feedback loops comes in many forms.
Compilation, unit tests and static code analysis provides feedback on your local development.
Continuous integration (CI) provides feedback on how well your change works together with other changes.
Continuous delivery (CD) provides feedback on how well your change works in production.
Metrics on how features are used provides feedback on how valuable your features are.</p><p>Regardless of what kind of feedback loop; the speed and quality of feedback constitutes your rate and quality of learning.
Be aware of your feedback loops and strive to improve them.</p><h3 id=deployability-vs-releasability>Deployability vs Releasability</h3><p>To ensure quick iteration times and speedy CI/CD it&rsquo;s helpful to separate
Deployability and Releasability.</p><p>Deployability means that the change is ready to merge and send to production.
But that does not mean that the feature has to be enabled or available for the
end user just yet. This means that the change passes the tests and the build
system. It&rsquo;s possible to merge into the main branch.
Releaseability is that the feature or fix is ready to enable for the end user.</p><p>This separation helps us develop larger features while still maintaining
a short time from code writing to deploy. This has a few advantages over long
running feature branches. It is much easier to merge since we only ever merge
to the main branch. Individual merges are smaller, and therefore easier
to review.
Parallel development always has a reference to the new
feature under development, so the branches won&rsquo;t diverge.</p><p>This separation is also a good stepping stone to more advanced
release-strategies like A/B testing and staged/gradual roll out.
It&rsquo;s usually achieved with feature flags.
But there are some drawbacks as always.
A feature flag system can become very
complex and it&rsquo;s hard to test all different combinations of flags.</p><h3 id=dont-trust-your-assumptions-formulate-a-hypothesis-and-test-it>Don&rsquo;t trust your assumptions: Formulate a hypothesis and test it</h3><p>Assumptions are a dangerous thing in development. You could argue that most
bugs are caused by faulty assumptions. Either a wrong assumption about how the
computer, language or the code work. Or a mistaken assumption about the
product, industry or the users needs.</p><p>How do you avoid this? One way is described in the book:
Formulate a hypothesis, then construct a test or experiment that can prove
or disprove it. The result is very valuable feedback. Then you know if the
assumption holds or not, without guessing or debating. Separating myth and
reality.</p><p>Then you formulate a better hypothesis, and test that. And then you iterate the
hypothesis-test cycle again. And again. As we do with a continuous improvement
culture.</p><p>But it is important to control the variables so that the experiment is
accurate and reproducible. How you do this is the hard part, it very much
depends on the conditions of the system under test and the hypothesis.</p><p>A related concept is self deception.
It is really easy to invent a reality that suits the argument you are trying
to make, regardless if it&rsquo;s true or not.
Sometimes you really want to believe certain things about your software systems.
The Hypothesis-test cycle is an effective way to guard against self deception as
well.</p><h3 id=measuring-team-performance>Measuring team performance</h3><p>It’s hard to measure performance of software development teams.
Will we deliver more if we start to use this other programming language?
Do we decrease the number of bugs and incidents by requiring manager approval prior to production deployments?</p><p>Farley refer a lot to the four DevOps metrics that relatively recently has been proposed in the <em>State of DevOps report</em>, and in the book <em>Accelerate</em>.
This is a set of metrics which aim to measure the <strong>throughput</strong> and <strong>stability</strong> of software delivery.
Throughput refers to how quick and how often the team can move ideas into production.
Stability refer to the quality and robustness of changes, and how quick the team is able to recover from failed changes.
An interesting fact about these metrics is that high performers in throughput also tend to be high performers in stability, and vice versa (contrary to the traditional <a href=https://en.wikipedia.org/wiki/Project_management_triangle>project management triangle</a>).</p><p>Of course, the metrics alone doesn&rsquo;t tell us everything; e.g. the actual value of changes are not represented in the metrics.
Regardless, the four DevOps metrics are important.
We finally have an objective tool that can reinforce or invalidate our subjective judgement.
We can measure the impact of changes to organization, process, culture and technology.
Pretty epic.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://blog.devies.se/>&copy; Devies Tech Culture Business Blog 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>