<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Migrating data between DynamoDB tables | Devies blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the official AWS documentation states that “you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”, you often need to experiment to be able to discover what those questions are."><meta name=generator content="Hugo 0.99.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/blog/ananke/css/main.min.ceb444b34b6d1508dbe3ab8cbf937a305a3f952886a8f52fbbb14068f75e1a94.css><link rel="shortcut icon" href=/blog/favicon.ico type=image/x-icon><meta property="og:title" content="Migrating data between DynamoDB tables"><meta property="og:description" content="When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the official AWS documentation states that “you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”, you often need to experiment to be able to discover what those questions are."><meta property="og:type" content="article"><meta property="og:url" content="https://deviesdevelopment.github.io/blog/posts/2021-03-30-dynamodb-migrations/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-30T10:34:41+00:00"><meta property="article:modified_time" content="2021-03-30T10:34:41+00:00"><meta itemprop=name content="Migrating data between DynamoDB tables"><meta itemprop=description content="When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the official AWS documentation states that “you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”, you often need to experiment to be able to discover what those questions are."><meta itemprop=datePublished content="2021-03-30T10:34:41+00:00"><meta itemprop=dateModified content="2021-03-30T10:34:41+00:00"><meta itemprop=wordCount content="864"><meta itemprop=keywords content="AWS,DynamoDB,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Migrating data between DynamoDB tables"><meta name=twitter:description content="When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the official AWS documentation states that “you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”, you often need to experiment to be able to discover what those questions are."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/blog/logo.png class="w100 mw5-ns" alt="Devies blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Migrating data between DynamoDB tables</h1><p class=tracked>By <strong>Gustav Sundin, Rickard Andersson</strong></p><time class="f6 mv4 dib tracked" datetime=2021-03-30T10:34:41Z>March 30, 2021</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the <a href=https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html>official AWS documentation</a> states that <em>“you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”</em>, you often need to experiment to be able to discover what those questions are. Luckily there is an easy approach for how to migrate to a new key schema that we will describe in this blog post.</p><p>In short, the process looks like this:</p><ol><li>Create the target table</li><li>Synchronize incoming changes to the target table using <a href=https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/>DynamoDB Streams</a></li><li>Migrate existing items</li><li>Start reading from the target table</li><li>Start writing to the target table</li><li>Delete the original table</li></ol><p>Changing key schemas is not the only use case for this method. The same approach can also be used to split or merge multiple tables, to manipulate data items, or to get rid of unwanted data. The main advantages of this approach is that it requires no downtime, is easily reversible, and guarantees that no data is lost during the migration process.</p><p>This blog post also comes with a <a href=https://github.com/DeviesDevelopment/dynamodb-migration>companion example repo</a>.</p><p><em>Note that if you’re simply looking for replicating a table over multiple regions, you should have a look at <a href=https://aws.amazon.com/dynamodb/global-tables/>DynamoDB Global Tables</a> instead.</em></p><h2 id=create-target-table>Create target table</h2><p>Before we begin with the actual migration, the target table needs to be in place. Create this table as you normally would, using CloudFormation or elsewise.</p><h2 id=synchronize-changes-using-dynamodb-streams>Synchronize changes using DynamoDB Streams</h2><p>Before we can start using the target table, we need to migrate the data. In our approach we use <a href=https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/>DynamoDB Streams</a>, which is an AWS managed stream of change events that happen to a DynamoDB table. The stream is guaranteed to contain all events in a time-ordered sequence, meaning that we can guarantee that no data loss will occur during the migration.</p><p>To actually migrate data, something needs to be triggered on the change events. For this we use an AWS Lambda function. The function gets the change event as input, and will apply the corresponding change to the target table. For a concrete code example, see <a href=https://github.com/DeviesDevelopment/dynamodb-migration>this repo</a>.</p><p>Note that if any transformation of the item needs to be made, it should happen here in the Lambda function. As stated, this could be anything from one-to-one mapping into a new data format to splitting up the data across multiple target tables.</p><p>An alternative to using DynamoDB Streams is to use <a href=https://aws.amazon.com/datapipeline/>AWS Data Pipeline</a>, which might be better suited for cross account migrations.</p><h2 id=migrate-existing-items>Migrate existing items</h2><p>Now that we have our stream in place, we can be certain that any changes in the original table will be propagated to the target table. We can also leverage the same stream to migrate all the existing data as well. This is as simple as writing a script that makes some update to every item in the original table, meaning that every item will also end up on the DynamoDB stream. This could be as easy as adding some property (such as the “migrate” property in our <a href=https://github.com/DeviesDevelopment/dynamodb-migration>example</a>), which is trimmed off in the Lambda function before the item is written to the target table.</p><h2 id=update-code-to-read-from-target-table>Update code to read from target table</h2><p>At this point we are certain that every item in the original table has been written to the target table, and that any new changes are propagated to the target table. The next step is to update application code to actually read from the target table. There is no need to change all application code at once since both original and target tables will contain the same data (note that there might be a short delay until any written data is available in the target table).
Update code to write to target table</p><p>The next step is to update application code so that it writes to the target table as well. Before we do this we need to be certain that nothing is still reading from the old table. The best way to ensure this is to look at the read capacity metric in the AWS console. Just like with the read operations, there is no need to change everything at once.</p><h2 id=delete-original-table>Delete original table</h2><p>Once all application code is updated to write to the target table, the original table is not used anymore and can be deleted. Before doing so, it could be a good idea to monitor the read and write capacity metrics for a while to make sure you haven’t missed anything.</p><p>The approach described in this blog post is a safe and relatively easy way to migrate data between DynamoDB tables. Thus, it’s not completely true that <em>“you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”</em>. On the contrary, it is actually quite straightforward to make changes to an existing key schema, as long as you do it in a controlled manner. This allows for experimentation and iterative development in any DynamoDB-backed application.</p><p>By Gustav Sundin & Rickard Andersson</p><ul class=pa0><li class=list><a href=/blog/tags/aws class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">AWS</a></li><li class=list><a href=/blog/tags/dynamodb class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">DynamoDB</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://deviesdevelopment.github.io/blog>&copy; Devies blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>