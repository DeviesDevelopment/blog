<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>How I've automated the setup of my virtual server | Devies blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Lately I&rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&rsquo;s a NGINX reverse proxy that forwards traffic to services."><meta name=generator content="Hugo 0.102.3"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/blog/ananke/css/main.min.9036e8ca4a3287e27ab2eb511a473b75bdc83acf6db11ab67b1704e7b4fdd475.css><link rel="shortcut icon" href=/blog/favicon.ico type=image/x-icon><meta property="og:title" content="How I've automated the setup of my virtual server"><meta property="og:description" content="Lately I&rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&rsquo;s a NGINX reverse proxy that forwards traffic to services."><meta property="og:type" content="article"><meta property="og:url" content="https://deviesdevelopment.github.io/blog/posts/automated-ec2-setup/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-21T05:57:22+01:00"><meta property="article:modified_time" content="2022-01-21T05:57:22+01:00"><meta itemprop=name content="How I've automated the setup of my virtual server"><meta itemprop=description content="Lately I&rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&rsquo;s a NGINX reverse proxy that forwards traffic to services."><meta itemprop=datePublished content="2022-01-21T05:57:22+01:00"><meta itemprop=dateModified content="2022-01-21T05:57:22+01:00"><meta itemprop=wordCount content="1519"><meta itemprop=keywords content="Automation,Infrastructure as Code,AWS,Terraform,Ansible,Github Actions,"><meta name=twitter:card content="summary"><meta name=twitter:title content="How I've automated the setup of my virtual server"><meta name=twitter:description content="Lately I&rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&rsquo;s a NGINX reverse proxy that forwards traffic to services."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/blog/logo.png class="w100 mw5-ns" alt="Devies blog"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">How I've automated the setup of my virtual server</h1><p class=tracked>By <strong>Rickard Andersson</strong></p><time class="f6 mv4 dib tracked" datetime=2022-01-21T05:57:22+01:00>January 21, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Lately I&rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&rsquo;s a NGINX reverse proxy that forwards traffic to services. I decided to try the same approach.</p><p><img src=/blog/ec2-docker.png alt="EC2 instance, with docker containers and NGINX reverse proxy"></p><p>The server accepts traffic on port 80 and 443. To decide which service that should receive a request, NGINX inspects the hostname of the request and forwards traffic to respective service (docker container).</p><p>To accomplish this I will need a bunch of things. First of all I need an EC2 instance in AWS. Second, docker, and perhaps docker-compose will need to be installed in order to run services. Finally, the NGINX reverse proxy must be configured and started in some way. One approach would be to manually create an EC2 instance in the AWS portal, SSH into the server, install and configure everything. But what if I would later accidentally delete my server? Or AWS has an outage affecting my server? Then there&rsquo;s a risk I&rsquo;ll have to recreate my server and configure everything from scratch again, and when that happens, I probably won&rsquo;t remember how I&rsquo;ve configured it in the first place.</p><p>This calls for automation! Steps I take to deploy and configure the server can be described in code and executed by software. This has a lot of advantages. There&rsquo;s no risk of me forgetting how I&rsquo;ve deployed and configured the server (since I have it described in code), and if I for some reason need to repeat the whole process, I can simply execute the steps again.</p><p>In this post I will describe how I&rsquo;ve automated this process. The automation runs in a <a href=https://github.com/features/actions>Github Actions</a> workflow where I use <a href=https://www.terraform.io/>Terraform</a> and <a href=https://www.ansible.com/>Ansible</a> to deploy and configure my server. Note that I will not go into detail on how to use the respective tools, but rather describe the general process of deploying and configuring my server with the tools.</p><h1 id=deploy-server>Deploy server</h1><p>First of all, I need a virtual server. As described above I&rsquo;ll go for an EC2 instance hosted in AWS. To have it deployed to my AWS account I use Terraform.</p><p>Terraform is a great tool which lets you automate deployment of resources in different cloud environments (such as AWS, GCP, Azure). To use it, you describe what resources you need to create in templates with a language/syntax called HCL. Then, you use the Terraform CLI to <em>apply</em> these templates to your cloud environment. To apply means to create, update or delete resources in the cloud environment to reflect what you&rsquo;ve described in your templates.</p><p>Below is a subset of the template containing resources I need for my server. Apart from that the template also includes a bunch of network-related resources and domain names. You can see the full template <a href=https://github.com/Dunklas/app-server/tree/main/iac>here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_instance&#34; &#34;app_server&#34;</span> {
</span></span><span style=display:flex><span>  ami                    <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>aws_ami</span>.<span style=color:#66d9ef>ubuntu</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>  instance_type          <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;t2.micro&#34;</span>
</span></span><span style=display:flex><span>  key_name               <span style=color:#f92672>=</span> <span style=color:#66d9ef>aws_key_pair</span>.<span style=color:#66d9ef>deployer</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>  vpc_security_group_ids <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;${aws_security_group.sg.id}&#34;</span>]
</span></span><span style=display:flex><span>  subnet_id              <span style=color:#f92672>=</span> <span style=color:#66d9ef>aws_subnet</span>.<span style=color:#66d9ef>subnet</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_eip&#34; &#34;ip&#34;</span> {
</span></span><span style=display:flex><span>  instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>aws_instance</span>.<span style=color:#66d9ef>app_server</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>  vpc      <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_key_pair&#34; &#34;deployer&#34;</span> {
</span></span><span style=display:flex><span>  key_name   <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>key_pair_name</span>
</span></span><span style=display:flex><span>  public_key <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>key_pair_public_key</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>output</span> <span style=color:#e6db74>&#34;server_ip&#34;</span> {
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> <span style=color:#66d9ef>aws_eip</span>.<span style=color:#66d9ef>ip</span>.<span style=color:#66d9ef>public_ip</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The resource of type <code>aws_instance</code> describes the actual EC2 instance. It&rsquo;s of type <code>t2.micro</code> and uses an Ubuntu image. To deploy these resources I run a <a href=https://github.com/Dunklas/app-server/blob/main/.github/workflows/main.yml>github actions workflow</a> where I use the Terraform CLI to have these resources created in my AWS account.</p><p>So, I now have a virtual server that runs Ubuntu, but there&rsquo;s still stuff left to do. I need to install docker and configure the NGINX reverse proxy. In order to do this automatically in a github actions workflow I need to: (1) have knowledge about what IP address the new server have; (2) be able to access the new server via SSH.</p><p>In above terraform template you can see that I&rsquo;ve used an <code>aws_eip</code> resource to assign an <a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html>elastic IP address</a> to the EC2 instance. Further, I expose the actual IP address as an output. By doing this, I can query what IP address that has been assigned to the new server with the Terraform CLI by running the following command: <code>terraform output -raw server_ip</code>.</p><p>To enable access to the server via SSH I have associated a <code>aws_key_pair</code> resource to the EC2 instance. Prior to applying the terraform template I&rsquo;ve generated an SSH key pair and included the public key in the <code>public_key</code> property. This means that I will be able to use the private key of the key pair to authenticate to the server via SSH. I&rsquo;ve added the private key as a repository secret in order to access it from my github actions workflow.</p><h1 id=configure-server>Configure server</h1><p>Now I have a server running Ubuntu. I also have knowledge about what IP address the server have, and I have a private key which I can access from my github actions workflow in order to authenticate to the server. To actually do things (such as installing applications) on the server I use <a href=https://www.ansible.com>Ansible</a>.</p><p>With Ansible you write <em>playbooks</em> that contains a sequence of <em>tasks</em>, and each task describes a desired state (e.g. application X is installed, or user Y is member of group Z). Then you can run these playbooks on a remote machine (or many) to get the desired state. By default Ansible uses SSH in order to execute commands on a remote machine.</p><p>Below are some of the tasks from my playbook that are responsible for making sure that docker is installed. You can see the full sequence of tasks for installing docker and docker-compose <a href=https://github.com/Dunklas/app-server/blob/main/playbooks/docker-install.yml>here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Set up the stable repository</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apt_repository</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>repo</span>: <span style=color:#ae81ff>deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>update_cache</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Update apt packages</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apt</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>update_cache</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install docker</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apt</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>docker-ce</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>update_cache</span>: <span style=color:#66d9ef>yes</span>
</span></span></code></pre></div><p>To tell Ansible what remote machine(s) to run a playbook on you provide an inventory file. This file can have many <a href=https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html>different formats</a>, but the essence of it is that it describes what machines to run on, and optionally how Ansible should interact with the machine(s).</p><p>To enable Ansible to authenticate to the server, I found it easiest to start an ssh-agent and use <code>ssh-add</code> to add the private key mentioned in the previous section.</p><p>Below is a part of my github actions workflow (full version available <a href=https://github.com/Dunklas/app-server/blob/main/.github/workflows/main.yml>here</a>) where I create an inventory file, start an ssh-agent and then run my ansible playbook on the new server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v2</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>echo ${{ env.SERVER_IP }} &gt;&gt; inventory.ansible</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup SSH key</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ssh-agent -a $SSH_AUTH_SOCK &gt; /dev/null
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ssh-add - &lt;&lt;&lt; $(echo &#34;${{ secrets.SSH_PRIVATE_KEY }}&#34; | base64 -d)</span>      
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Add server to known hosts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>run</span>: <span style=color:#ae81ff>mkdir ~/.ssh &amp;&amp; ssh-keyscan -H ${{ env.SERVER_IP }} &gt;&gt; ~/.ssh/known_hosts</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Configure server</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      ansible-playbook \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        --inventory inventory.ansible \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        --user ubuntu \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        main.yml</span>      
</span></span></code></pre></div><p>So, by running Ansible in my github actions workflow I can make sure that certain applications are installed on the new server after it has been created. Apart from installing docker and docker compose, I also need to have a reverse proxy up and running.</p><h2 id=reverse-proxy>Reverse proxy</h2><p>As reverse proxy I use <a href=https://github.com/DeviesDevelopment/frontman>Frontman</a>. Frontman launches an NGINX instance that redirects traffic to one of many locally running Docker containers based on the base URL of the incoming requests, which is exactly what we want to do.</p><p>To use Frontman, you need to create a configuration file that declares what domain names it should redirect traffic for. For each domain name, you also specify an upstream port that traffic will be redirected to. With the configuration file in place, you can launch Frontman by running <code>make start</code>.</p><p>Now, how do I make sure that Frontman is automatically started on the new server? Above I used Ansible to ensure that certain applications are installed. However, you can use Ansible for much more than that.</p><p>Each Ansible task uses a <em><a href=https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html>module</a></em>. To install docker I used modules such as <a href=https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_repository_module.html>apt-repository</a> and <a href=https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html>apt</a>. To make sure Frontman is started I instead use the modules <a href=https://docs.ansible.com/ansible/latest/collections/ansible/builtin/git_module.html>git</a>, <a href=https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html>copy</a> and <a href=https://docs.ansible.com/ansible/2.9/modules/make_module.html>make</a> in order to: (1) Clone the Frontman repository; (2) Copy configuration file to server; (3) Run <code>make start</code> to launch Frontman. You can see the full sequence of tasks <a href=https://github.com/Dunklas/app-server/blob/main/playbooks/configure-proxy.yml>here</a>.</p><h1 id=final-thoughts>Final thoughts</h1><p>I really enjoy infrastructure as code and automation in general. Since everything is described in code, I have a complete understanding of how I&rsquo;ve configured my server and of what resources I use in my AWS account. If the need should arise, I can tear down my server and recreate it from scratch just by running my github actions workflow. This gives me both comfort and confidence.</p><p>I did not cover how I deploy services (docker containers) to the server in this post. There&rsquo;s actually a few different ways you could do this, which I might cover in a future post.</p><p>If you&rsquo;re interested, everything I&rsquo;ve described in this post is available in <a href=https://github.com/Dunklas/app-server>this repository</a>.</p><p>By Rickard Andersson</p><ul class=pa0><li class=list><a href=/tags/automation class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Automation</a></li><li class=list><a href=/tags/infrastructure-as-code class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Infrastructure as Code</a></li><li class=list><a href=/tags/aws class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">AWS</a></li><li class=list><a href=/tags/terraform class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Terraform</a></li><li class=list><a href=/tags/ansible class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Ansible</a></li><li class=list><a href=/tags/github-actions class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Github Actions</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/posts/aws-timestream/>Trying out AWS Timestream</a></li><li class=mb2><a href=/blog/posts/implementation/aws/2021/04/08/minimize-java-lambda-coldstarts.html/>Minimize Java Lambda Cold Start Times</a></li><li class=mb2><a href=/blog/posts/2021-03-30-dynamodb-migrations/>Migrating data between DynamoDB tables</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://deviesdevelopment.github.io/blog>&copy; Devies blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>