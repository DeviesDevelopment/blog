---
title: "Learn the Tools in the Toolbox"
date: 2022-09-23T14:25:08+02:00
tags: []
featured_image: ""
description: ""
slug: "learn-the-tools-in-the-toolbox"
author:
 - Fredrik Mile 
---

Last week I ended up spending more time than I expected on debugging.
Most of the time was spent on figuring out why a library, did not accept our freshly generated rsa private key.
I was suppose provide the rsa private key as an enviornemnt variable `RSA_PRIVATE_KEY`, but I wanted to store the rsa private key in a file `private-key.pem`.
My first attempt became `RSA_PRIVATE_KEY=\"$(cat private-key.pem)\" docker-compose up -d` which failed due to decoding issues by the library.
It would appear that the library was very strict on how the `RSA_PRIVATE_KEY` should be provided, but in the end I managed to figure out. 

During the debugging, I learned a ton about a few UNIX tools. 
I realised that we have a great toolbox just in front of us all day which we should try to get to know a little better.
This toolbox, is part of Unix Development Tools and comes pre-installedd on most unix system (including Mac os X).
I will go through a subset of these tools in this post and explain how they helped me debug the decoding issue with the private key.

_The private-key.pem referenced in the following command was generated by `openssl genrsa -out private-key.pem 3072`_

## File

The `File` command classifies the specified file.
The command determinates the type of the file and it can be used to view the mime type of the file (using the -I flag).
The mime type corresponds to the media type and can help you verify that the file is of the type/format you expect it to be.

	» file private-key.pem
	private-key.pem: PEM RSA private key
	» file -I private-key.pem
	private-key.pem: text/plain; charset=us-ascii

The above output from `File` is expected, it shows that the file is of the type that we expect.
If `file private-key.pem` would have returned `private-key.pem: ASCII text`, it would have been a red flag indicating that the file is not of the expected type.

## Sed

By viewing the content of `private-key.pem`, I could see that it contained linebreaks, and I was afraid that they caused the issue. 
I wanted to replace the linebreaks with the newline character `\n` and to do this I grabbed `sed` from the toolbox.

`Sed` reads the specified input stream and modifies it according to the given commands or regex.

	» sed 's/$/\\n/' private-key.pem
	-----BEGIN RSA PRIVATE KEY-----\n
	MIIG4wIBAAKCAYEA4CN/W5vGK8qbYN7zL7s2g5jhI5afW3kfXbITCDe19Dwt4/p7\n
	/k8+cEFFxnC+yJQpcgBm7nbWkMRkx53RpR2UHlMpcKhCImPnl5IN0Zv6L9xsQvuL\n
	...
	prO6CylgkdImkNN4BN/sSDwTFTS7Aqed+YpdeNTUIFy4HQVYYUBw\n
	-----END RSA PRIVATE KEY-----\n

Above, the `sed` command `s (substitute)` was used. 
This command changes all occurences of something to something else. 
The syntax of the `sed s` command is: `sed s/before/after`, meaning that `s/$/\\n/` substitutes all `$ (linebreaks)` with `\n`.
Unfortunately, this substition did not solve my problem.

## Hexdump

The next tool to grab from the toolbox was `Hexdump` which displays the content of the file in different formats, one being hexadecimal.
Hexdump is very helpful to display hidden characters (linebreaks, newlines, tabs, spaces and etc) which is difficult to identify manually.

	» hexdump -C private-key.pem
	00000000  2d 2d 2d 2d 2d 42 45 47  49 4e 20 52 53 41 20 50  |-----BEGIN RSA P|
	00000010  52 49 56 41 54 45 20 4b  45 59 2d 2d 2d 2d 2d 0a  |RIVATE KEY-----.|
	00000020  4d 49 49 47 34 77 49 42  41 41 4b 43 41 59 45 41  |MIIG4wIBAAKCAYEA|
	...
	00000970  48 51 56 59 59 55 42 77  0a 2d 2d 2d 2d 2d 45 4e  |HQVYYUBw.-----EN|
	00000980  44 20 52 53 41 20 50 52  49 56 41 54 45 20 4b 45  |D RSA PRIVATE KE|
	00000990  59 2d 2d 2d 2d 2d 0a                              |Y-----.|

The `-C` flag sets the output format to hexadecimal. Each row of the output contains 16 characters, each displayed as their hexadecimal representation.
The byte value is `2d` and by looking up `2d` in an [ascii-table](https://www.asciitable.com/). we can see that `2d` corresponds to `-`, meaning that we have no unwanted characters in the begning of the file.
The last binary value was `0a` which represent `LF` which is the character that indicates the end of the line. It is not the same as newline `\n` or carriage return `\r`.

# Diff

Running out of ideas of potential next step I decided to test with a copy of the `private-key-pem`, named `private-key2.pem`.
I copied the content of `private-key.pem` by running `pbcopy < private-key.pem`, and I opened my editor and pasted the content into `private-key2.pem`.
To my suprise, the application started when I ran it with `private-key2.pem`, the **COPY** of `private-key-pem`.

To understand why this was possible, I grabbed a new tool from the toolbox, `Diff`.
This tool, compares files line by line.

	» diff private-key.pem private-key2.pem
	39a40
	>

The output of `Diff` above shows that there is a minor difference between the files.
`39a40` represents the change: _starting at row `39`, add line(s) until reaching row`40`_. 


Running the `Diff` command in reversed order shows the same thing but from the perspective of `private-key.pem`

	» diff private-key2.pem private-key.pem                                                                                                                                 1 ↵
	40d39
	<

`40d39` represents the change: _starting at row `40`, delete line(s) until row `39`._ The output from `Diff` can be seen as instructions towards making the files identical.

## Conclusion

To conclude, all that was missing was a `\n` at the end of the file. The key generation command excluded the neccessary newline, but my editor decided to add it.
Alot of work for just a missing newline, but I realised that the included toolbox is quite powerful.
We should all try to get a familar with the tools, you never know when you may need them in the future.

## Honarable mentions

There's a few more tools I want to mention before this post is over.

#### `pipe |`

Let's you use the output from one command as input to another command.
	
	» sed 's/$/\\n/' private-key.pem | hexdump                                                                                                                        130 ↵

	0000000 2d2d 2d2d 422d 4745 4e49 5220 4153 5020
	0000010 4952 4156 4554 4b20 5945 2d2d 2d2d 5c2d
	0000020 0a6e 494d 4749 4135 4249 4141 434b 5941

### `grep`

Search for information

	» cat private-key.pem | grep RSA                                                                                                                                      130 ↵
	-----BEGIN RSA PRIVATE KEY-----
	-----END RSA PRIVATE KEY-----

### `man`

Show the manual and instructions of the given command.

» man grep

	GREP(1)                      General Commands Manual                     GREP(1)

	NAME
     grep, egrep, fgrep, rgrep, bzgrep, bzegrep, bzfgrep, zgrep, zegrep, zfgrep
     – file pattern searcher

	SYNOPSIS
     grep [-abcdDEFGHhIiJLlMmnOopqRSsUVvwXxZz] [-A num] [-B num] [-C[num]]
          [-e pattern] [-f file] [--binary-files=value] [--color[=when]]
          [--colour[=when]] [--context[=num]] [--label] [--line-buffered]
          [--null] [pattern] [file ...]

	DESCRIPTION
     The grep utility searches any given input files, selecting lines that match
     one or more patterns.  By default, a pattern matches an input line if the
     regular expression (RE) in the pattern matches the input line without its
     trailing newline.  An empty expression matches every line.  Each input line
     that matches at least one of the patterns is written to the standard
     output.

