<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.NET on Devies Tech Culture Business Blog</title><link>https://blog.devies.se/tags/.net/</link><description>Recent content in .NET on Devies Tech Culture Business Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 02 Aug 2022 09:07:50 +0200</lastBuildDate><atom:link href="https://blog.devies.se/tags/.net/index.xml" rel="self" type="application/rss+xml"/><item><title>Integration Test Api in .Net Using Reflection</title><link>https://blog.devies.se/posts/integration-test-api-controller-in-.net-using-reflection/</link><pubDate>Tue, 02 Aug 2022 09:07:50 +0200</pubDate><guid>https://blog.devies.se/posts/integration-test-api-controller-in-.net-using-reflection/</guid><description>&lt;p>There are a few different approaches to testing in the spectrum between simple unit tests and complete E2E tests. If I had to choose one approach to prioritize I would pick integration tests.&lt;/p>
&lt;p>The key reasons are:&lt;/p>
&lt;ul>
&lt;li>Tests a flow of multiple functions, in contrast with unit tests where only a single function is tested&lt;/li>
&lt;li>Self contained i.e. the test has no external dependencies on a deployed environment etc.&lt;/li>
&lt;li>Makes logical sense to test a complete function in a REST api, a single Lambda in AWS or an Azure function&lt;/li>
&lt;/ul>
&lt;h2 id="the-problem">The problem&lt;/h2>
&lt;p>In my case the goal was to setup a test suite for a .NET web api. I quickly realized that the naive way to explicitly instantiate every controller plus all dependencies would lead
to lots of repeated boilerplate code in order to setup a test case. I also wanted to make use of the existing &lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0">DI&lt;/a> configuration.&lt;br>
So how to create a generic setup where new test cases is a breeze to create? ðŸ¤”&lt;/p></description></item><item><title>Mitigating Primitive Obsession in ASP.NET Web Api</title><link>https://blog.devies.se/posts/mitigating-primitive-obsession-in-asp.net-web-api/</link><pubDate>Fri, 29 Jul 2022 15:43:58 +0200</pubDate><guid>https://blog.devies.se/posts/mitigating-primitive-obsession-in-asp.net-web-api/</guid><description>&lt;p>One of the projects we work with at Devies is related to the dental domain.
In that project we use the &lt;a href="https://en.wikipedia.org/wiki/Dental_notation">dental notation (ISO 3950)&lt;/a> to refer to teeth.
Every tooth have an unique identifier that consist of two characters.
The first character represent a quadrant (one of four areas in the mouth).
The second character is an identifier that refers to one of the eight teeth in that area.&lt;/p>
&lt;p>Early on in the project we represented the tooth identifier using a string, for example &lt;code>&amp;quot;42&amp;quot;&lt;/code> (4 is the quadrant, 2 is the identifier).
As the project grew we stared to use this tooth identifier in many different places in the project.
Since we use a raw string, we had to make sure the tooth identifier was properly validated at every place where it was used.
Additionally, it was unclear what the tooth identifier (string) represented, and it affected the readability of our code.&lt;/p></description></item></channel></rss>