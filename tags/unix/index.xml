<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unix on Devies Tech Culture Business Blog</title><link>https://blog.devies.se/tags/unix/</link><description>Recent content in Unix on Devies Tech Culture Business Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 26 Sep 2022 08:25:08 +0200</lastBuildDate><atom:link href="https://blog.devies.se/tags/unix/index.xml" rel="self" type="application/rss+xml"/><item><title>Take Advantage of the Tools in the Toolbox</title><link>https://blog.devies.se/posts/learn-the-tools-in-the-toolbox/</link><pubDate>Mon, 26 Sep 2022 08:25:08 +0200</pubDate><guid>https://blog.devies.se/posts/learn-the-tools-in-the-toolbox/</guid><description>&lt;p>Last week I ended up spending more time than I expected on debugging.
I spent most of the time figuring out why a library did not accept my freshly generated RSA private key.
I was supposed to provide the RSA private key as an environment variable &lt;code>RSA_PRIVATE_KEY&lt;/code>. I wanted to store the RSA private key in a file &lt;code>private-key.pem&lt;/code> so my first attempt became &lt;code>RSA_PRIVATE_KEY=\&amp;quot;$(cat private-key.pem)\&amp;quot; docker-compose up -d&lt;/code>, which failed due to decoding issues by the library.
It would appear that the library was very strict on the format of the private key.
After a lot of debugging, I managed to figure out how I was supposed to provide the private key and I will try to share my learnings here.&lt;/p></description></item></channel></rss>