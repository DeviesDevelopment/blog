<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Azure AD on Devies Tech Culture Business Blog</title><link>https://blog.devies.se/tags/azure-ad/</link><description>Recent content in Azure AD on Devies Tech Culture Business Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 15 Mar 2022 20:15:15 +0100</lastBuildDate><atom:link href="https://blog.devies.se/tags/azure-ad/index.xml" rel="self" type="application/rss+xml"/><item><title>Using managed identities and role based access control is great!</title><link>https://blog.devies.se/posts/managed-identities-and-rbac-is-great/</link><pubDate>Tue, 15 Mar 2022 20:15:15 +0100</pubDate><guid>https://blog.devies.se/posts/managed-identities-and-rbac-is-great/</guid><description>&lt;p>In a project I work with we use &lt;a href="https://docs.microsoft.com/en-us/azure/app-service/overview">Azure App Service&lt;/a> for hosting an ASP.NET application. All external configuration used by the application is stored in an &lt;a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview">Azure App Configuration&lt;/a> store. I recently updated how the application authenticates toward the App Configuration store and think it worked out pretty well.&lt;/p>
&lt;p>Prior to the change we used connection strings (i.e. a string containing endpoint, username and password) for authentication. The main drawback with this is that we have to manage the credentials ourselves. We must provide the connection string to the application in some way (e.g. set it in a CI/CD pipeline after deploying our application). If our connection string is compromised, we must regenerate it and make sure that the application is provided with the new one.&lt;/p></description></item></channel></rss>