<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AWS on Devies blog</title><link>https://deviesdevelopment.github.io/blog/tags/aws/</link><description>Recent content in AWS on Devies blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 21 Jan 2022 05:57:22 +0100</lastBuildDate><atom:link href="https://deviesdevelopment.github.io/blog/tags/aws/index.xml" rel="self" type="application/rss+xml"/><item><title>How I've automated the setup of my virtual server</title><link>https://deviesdevelopment.github.io/blog/posts/automated-ec2-setup/</link><pubDate>Fri, 21 Jan 2022 05:57:22 +0100</pubDate><guid>https://deviesdevelopment.github.io/blog/posts/automated-ec2-setup/</guid><description>Lately I&amp;rsquo;ve been looking for a good way of hosting some personal projects. I wanted something relatively cheap which I could use to host multiple services. A colleague of mine have for a long time used a single virtual server (more specifically, an EC2 instance in AWS) where he runs multiple services inside docker containers. To enable access to each individual service, there&amp;rsquo;s a NGINX reverse proxy that forwards traffic to services.</description></item><item><title>Trying out AWS Timestream</title><link>https://deviesdevelopment.github.io/blog/posts/aws-timestream/</link><pubDate>Wed, 22 Dec 2021 15:50:15 +0100</pubDate><guid>https://deviesdevelopment.github.io/blog/posts/aws-timestream/</guid><description>AWS recently (last year) released their new server-less database focused purely on time series data, Amazon Timestream. On their product page, AWS describes the database like:
&amp;ldquo;Amazon Timestream is a fast, scalable, and serverless time series database service for IoT and operational applications that makes it easy to store and analyze trillions of events per day up to 1,000 times faster and at as little as 1/10th the cost of relational databases.</description></item><item><title>Minimize Java Lambda Cold Start Times</title><link>https://deviesdevelopment.github.io/blog/posts/implementation/aws/2021/04/08/minimize-java-lambda-coldstarts.html/</link><pubDate>Thu, 08 Apr 2021 09:25:58 +0000</pubDate><guid>https://deviesdevelopment.github.io/blog/posts/implementation/aws/2021/04/08/minimize-java-lambda-coldstarts.html/</guid><description>If you have ever run Java inside a lambda function on AWS, you will have noticed the quite significant cold start times that comes with spinning up the JVM environment. In this post, I will discuss some different tricks you can use to minimize these cold start times.
The problem with cold starts arises when there are no &amp;ldquo;warm&amp;rdquo; lambda available to handle an incoming request, which usually happens whenever an endpoint experiences a large and sudden spike in traffic.</description></item><item><title>Migrating data between DynamoDB tables</title><link>https://deviesdevelopment.github.io/blog/posts/2021-03-30-dynamodb-migrations/</link><pubDate>Tue, 30 Mar 2021 10:34:41 +0000</pubDate><guid>https://deviesdevelopment.github.io/blog/posts/2021-03-30-dynamodb-migrations/</guid><description>When setting up a new DynamoDB table, an important decision is to decide what primary key to use. However, it’s not uncommon to not have the full picture up front and therefore it could be hard to make the right decision beforehand. While the official AWS documentation states that “you shouldn’t start designing your schema for DynamoDB until you know the questions it will need to answer”, you often need to experiment to be able to discover what those questions are.</description></item></channel></rss>