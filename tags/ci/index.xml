<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CI on Devies Tech Culture Business Blog</title><link>https://blog.devies.se/tags/ci/</link><description>Recent content in CI on Devies Tech Culture Business Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 27 Jul 2022 16:43:10 +0200</lastBuildDate><atom:link href="https://blog.devies.se/tags/ci/index.xml" rel="self" type="application/rss+xml"/><item><title>Conventional Commits and Generating Changelogs</title><link>https://blog.devies.se/posts/conventional-commits-and-generating-changelogs/</link><pubDate>Wed, 27 Jul 2022 16:43:10 +0200</pubDate><guid>https://blog.devies.se/posts/conventional-commits-and-generating-changelogs/</guid><description>&lt;p>Documentation, while in many cases important, might not be the first thing you as a developer want to spend time on doing.
Something you might do like as a developer is to spend a lot of time automating simple but tedious tasks in order to never have to do it manually again!
With documentation being a particularly important part in our project we were extra keen on finding as many ways of automating documentation as possible.
In this post I will go through how we utilized &lt;code>Conventional Commits&lt;/code>, an Azure Devops extension called &lt;code>Commitizen&lt;/code> and an npm package called &lt;code>Standard version&lt;/code> to automatically generate changelogs in our Azure Devops CI environment.&lt;/p></description></item><item><title>We Got Cached ðŸ˜±</title><link>https://blog.devies.se/posts/we-got-cached/</link><pubDate>Fri, 13 May 2022 13:29:31 +0200</pubDate><guid>https://blog.devies.se/posts/we-got-cached/</guid><description>&lt;p>For the past couple of weeks, we&amp;rsquo;ve been working on a React app from scratch. Additionally, we&amp;rsquo;ve added pipelines in Azure as an attempt to achieve &lt;span style="font-family:Arial;color:#00c0ff;">MAXIMUM EFFICIENCY&lt;/span> when it comes to deployment and integration. So there we are. It&amp;rsquo;s a lovely morning. The sun is shining, the coffee is warm, and we&amp;rsquo;re ready to drop some lines of code! ðŸ˜Ž&lt;/p>
&lt;p>Last week we built and deployed a version of our React app that had a slightly faulty CSS attribute that made the header of the app take up the whole screen. Thus our first and foremost task was to fix it so that it only takes up a small area at the top of the screen. We used the Inspection feature in Firefox Developer Edition to pinpoint the faulty CSS and determine the issue, which we managed to do. The next step was to apply that fix in our code to see what would happen. The fix worked locally by running the React app using &lt;code>yarn start&lt;/code> as well as deploying a Docker image. Great, the fix is ready to be deployed using our Azure pipelines!&lt;/p></description></item><item><title>Why you should add a cypress test to your CI/CD pipeline</title><link>https://blog.devies.se/posts/why-you-should-add-a-cypress-test-to-your-ci-cd-pipeline/</link><pubDate>Thu, 12 May 2022 08:29:15 +0200</pubDate><guid>https://blog.devies.se/posts/why-you-should-add-a-cypress-test-to-your-ci-cd-pipeline/</guid><description>&lt;p>Cypress is a framework for testing web applications, primarily used for end-to-end testing. In an end-to-end test you test your application as a whole just as a real user would, by interacting with GUI components, without any mocked components. The goal of this post is to convince you to add a single simple cypress test to your CI/CD pipeline.&lt;/p>
&lt;hr>
&lt;p>In end-to-end tests with cypress you can test a lot of aspects of your application with very little test code. Below is basically the simplest test you can write with cypress.&lt;/p></description></item></channel></rss>